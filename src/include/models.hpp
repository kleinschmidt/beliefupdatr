
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_conj_id_lapsing_fit_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_conj_id_lapsing_fit");
    reader.add_event(134, 134, "end", "model_conj_id_lapsing_fit");
    return reader;
}

class model_conj_id_lapsing_fit : public prob_grad {
private:
    int n;
    vector<double> x;
    int m;
    vector<int> z;
    int l;
    vector<int> y;
    int n_test;
    vector<double> x_test;
    vector<int> y_test;
    vector<vector<int> > z_test_counts;
    vector<vector<double> > xbar;
    vector<vector<double> > ss;
    vector<vector<double> > n_cat;
    double n_each;
public:
    model_conj_id_lapsing_fit(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_conj_id_lapsing_fit(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_conj_id_lapsing_fit_namespace::model_conj_id_lapsing_fit";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "n", "int", context__.to_vec());
            n = int(0);
            vals_i__ = context__.vals_i("n");
            pos__ = 0;
            n = vals_i__[pos__++];
            validate_non_negative_index("x", "n", n);
            context__.validate_dims("data initialization", "x", "double", context__.to_vec(n));
            validate_non_negative_index("x", "n", n);
            x = std::vector<double>(n,double(0));
            vals_r__ = context__.vals_r("x");
            pos__ = 0;
            size_t x_limit_0__ = n;
            for (size_t i_0__ = 0; i_0__ < x_limit_0__; ++i_0__) {
                x[i_0__] = vals_r__[pos__++];
            }
            context__.validate_dims("data initialization", "m", "int", context__.to_vec());
            m = int(0);
            vals_i__ = context__.vals_i("m");
            pos__ = 0;
            m = vals_i__[pos__++];
            validate_non_negative_index("z", "n", n);
            context__.validate_dims("data initialization", "z", "int", context__.to_vec(n));
            validate_non_negative_index("z", "n", n);
            z = std::vector<int>(n,int(0));
            vals_i__ = context__.vals_i("z");
            pos__ = 0;
            size_t z_limit_0__ = n;
            for (size_t i_0__ = 0; i_0__ < z_limit_0__; ++i_0__) {
                z[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "l", "int", context__.to_vec());
            l = int(0);
            vals_i__ = context__.vals_i("l");
            pos__ = 0;
            l = vals_i__[pos__++];
            validate_non_negative_index("y", "n", n);
            context__.validate_dims("data initialization", "y", "int", context__.to_vec(n));
            validate_non_negative_index("y", "n", n);
            y = std::vector<int>(n,int(0));
            vals_i__ = context__.vals_i("y");
            pos__ = 0;
            size_t y_limit_0__ = n;
            for (size_t i_0__ = 0; i_0__ < y_limit_0__; ++i_0__) {
                y[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "n_test", "int", context__.to_vec());
            n_test = int(0);
            vals_i__ = context__.vals_i("n_test");
            pos__ = 0;
            n_test = vals_i__[pos__++];
            validate_non_negative_index("x_test", "n_test", n_test);
            context__.validate_dims("data initialization", "x_test", "double", context__.to_vec(n_test));
            validate_non_negative_index("x_test", "n_test", n_test);
            x_test = std::vector<double>(n_test,double(0));
            vals_r__ = context__.vals_r("x_test");
            pos__ = 0;
            size_t x_test_limit_0__ = n_test;
            for (size_t i_0__ = 0; i_0__ < x_test_limit_0__; ++i_0__) {
                x_test[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("y_test", "n_test", n_test);
            context__.validate_dims("data initialization", "y_test", "int", context__.to_vec(n_test));
            validate_non_negative_index("y_test", "n_test", n_test);
            y_test = std::vector<int>(n_test,int(0));
            vals_i__ = context__.vals_i("y_test");
            pos__ = 0;
            size_t y_test_limit_0__ = n_test;
            for (size_t i_0__ = 0; i_0__ < y_test_limit_0__; ++i_0__) {
                y_test[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("z_test_counts", "n_test", n_test);
            validate_non_negative_index("z_test_counts", "m", m);
            context__.validate_dims("data initialization", "z_test_counts", "int", context__.to_vec(n_test,m));
            validate_non_negative_index("z_test_counts", "n_test", n_test);
            validate_non_negative_index("z_test_counts", "m", m);
            z_test_counts = std::vector<std::vector<int> >(n_test,std::vector<int>(m,int(0)));
            vals_i__ = context__.vals_i("z_test_counts");
            pos__ = 0;
            size_t z_test_counts_limit_1__ = m;
            for (size_t i_1__ = 0; i_1__ < z_test_counts_limit_1__; ++i_1__) {
                size_t z_test_counts_limit_0__ = n_test;
                for (size_t i_0__ = 0; i_0__ < z_test_counts_limit_0__; ++i_0__) {
                    z_test_counts[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            // initialize data variables
            validate_non_negative_index("xbar", "m", m);
            validate_non_negative_index("xbar", "l", l);
            xbar = std::vector<std::vector<double> >(m,std::vector<double>(l,double(0)));
            stan::math::fill(xbar,DUMMY_VAR__);
            validate_non_negative_index("ss", "m", m);
            validate_non_negative_index("ss", "l", l);
            ss = std::vector<std::vector<double> >(m,std::vector<double>(l,double(0)));
            stan::math::fill(ss,DUMMY_VAR__);
            validate_non_negative_index("n_cat", "m", m);
            validate_non_negative_index("n_cat", "l", l);
            n_cat = std::vector<std::vector<double> >(m,std::vector<double>(l,double(0)));
            stan::math::fill(n_cat,DUMMY_VAR__);
            n_each = double(0);
            stan::math::fill(n_each,DUMMY_VAR__);

            stan::math::assign(xbar, rep_array(0,m,l));
            stan::math::assign(ss, rep_array(0,m,l));
            stan::math::assign(n_cat, rep_array(0,m,l));
            for (int j = 1; j <= n; ++j) {
                {
                double delta(0.0);
                (void) delta;  // dummy to suppress unused var warning

                stan::math::initialize(delta, std::numeric_limits<double>::quiet_NaN());
                stan::math::fill(delta,DUMMY_VAR__);
                int cat(0);
                (void) cat;  // dummy to suppress unused var warning

                stan::math::fill(cat, std::numeric_limits<int>::min());
                int subj(0);
                (void) subj;  // dummy to suppress unused var warning

                stan::math::fill(subj, std::numeric_limits<int>::min());


                stan::math::assign(cat, get_base1(z,j,"z",1));
                stan::math::assign(subj, get_base1(y,j,"y",1));
                stan::math::assign(get_base1_lhs(get_base1_lhs(n_cat,cat,"n_cat",1),subj,"n_cat",2), (get_base1(get_base1(n_cat,cat,"n_cat",1),subj,"n_cat",2) + 1));
                stan::math::assign(delta, (get_base1(x,j,"x",1) - get_base1(get_base1(xbar,cat,"xbar",1),subj,"xbar",2)));
                stan::math::assign(get_base1_lhs(get_base1_lhs(xbar,cat,"xbar",1),subj,"xbar",2), (get_base1(get_base1(xbar,cat,"xbar",1),subj,"xbar",2) + (delta / get_base1(get_base1(n_cat,cat,"n_cat",1),subj,"n_cat",2))));
                stan::math::assign(get_base1_lhs(get_base1_lhs(ss,cat,"ss",1),subj,"ss",2), (get_base1(get_base1(ss,cat,"ss",1),subj,"ss",2) + (delta * (get_base1(x,j,"x",1) - get_base1(get_base1(xbar,cat,"xbar",1),subj,"xbar",2)))));
                }
            }
            stan::math::assign(n_each, ((1.0 * n) / (m * l)));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            ++num_params_r__;
            ++num_params_r__;
            validate_non_negative_index("mu_0", "m", m);
            num_params_r__ += m;
            validate_non_negative_index("sigma_0", "m", m);
            num_params_r__ += m;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_conj_id_lapsing_fit() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("kappa_0")))
            throw std::runtime_error("variable kappa_0 missing");
        vals_r__ = context__.vals_r("kappa_0");
        pos__ = 0U;
        context__.validate_dims("initialization", "kappa_0", "double", context__.to_vec());
        double kappa_0(0);
        kappa_0 = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,kappa_0);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable kappa_0: ") + e.what());
        }

        if (!(context__.contains_r("nu_0")))
            throw std::runtime_error("variable nu_0 missing");
        vals_r__ = context__.vals_r("nu_0");
        pos__ = 0U;
        context__.validate_dims("initialization", "nu_0", "double", context__.to_vec());
        double nu_0(0);
        nu_0 = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,nu_0);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable nu_0: ") + e.what());
        }

        if (!(context__.contains_r("mu_0")))
            throw std::runtime_error("variable mu_0 missing");
        vals_r__ = context__.vals_r("mu_0");
        pos__ = 0U;
        validate_non_negative_index("mu_0", "m", m);
        context__.validate_dims("initialization", "mu_0", "double", context__.to_vec(m));
        std::vector<double> mu_0(m,double(0));
        for (int i0__ = 0U; i0__ < m; ++i0__)
            mu_0[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < m; ++i0__)
            try {
            writer__.scalar_unconstrain(mu_0[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_0: ") + e.what());
        }

        if (!(context__.contains_r("sigma_0")))
            throw std::runtime_error("variable sigma_0 missing");
        vals_r__ = context__.vals_r("sigma_0");
        pos__ = 0U;
        validate_non_negative_index("sigma_0", "m", m);
        context__.validate_dims("initialization", "sigma_0", "double", context__.to_vec(m));
        std::vector<double> sigma_0(m,double(0));
        for (int i0__ = 0U; i0__ < m; ++i0__)
            sigma_0[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < m; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,sigma_0[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_0: ") + e.what());
        }

        if (!(context__.contains_r("lapse_rate")))
            throw std::runtime_error("variable lapse_rate missing");
        vals_r__ = context__.vals_r("lapse_rate");
        pos__ = 0U;
        context__.validate_dims("initialization", "lapse_rate", "double", context__.to_vec());
        double lapse_rate(0);
        lapse_rate = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,lapse_rate);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lapse_rate: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ kappa_0;
            (void) kappa_0;  // dummy to suppress unused var warning
            if (jacobian__)
                kappa_0 = in__.scalar_lb_constrain(0,lp__);
            else
                kappa_0 = in__.scalar_lb_constrain(0);

            T__ nu_0;
            (void) nu_0;  // dummy to suppress unused var warning
            if (jacobian__)
                nu_0 = in__.scalar_lb_constrain(0,lp__);
            else
                nu_0 = in__.scalar_lb_constrain(0);

            vector<T__> mu_0;
            size_t dim_mu_0_0__ = m;
            mu_0.reserve(dim_mu_0_0__);
            for (size_t k_0__ = 0; k_0__ < dim_mu_0_0__; ++k_0__) {
                if (jacobian__)
                    mu_0.push_back(in__.scalar_constrain(lp__));
                else
                    mu_0.push_back(in__.scalar_constrain());
            }

            vector<T__> sigma_0;
            size_t dim_sigma_0_0__ = m;
            sigma_0.reserve(dim_sigma_0_0__);
            for (size_t k_0__ = 0; k_0__ < dim_sigma_0_0__; ++k_0__) {
                if (jacobian__)
                    sigma_0.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    sigma_0.push_back(in__.scalar_lb_constrain(0));
            }

            T__ lapse_rate;
            (void) lapse_rate;  // dummy to suppress unused var warning
            if (jacobian__)
                lapse_rate = in__.scalar_lub_constrain(0,1,lp__);
            else
                lapse_rate = in__.scalar_lub_constrain(0,1);


            // transformed parameters
            validate_non_negative_index("mu_n", "m", m);
            validate_non_negative_index("mu_n", "l", l);
            vector<vector<T__> > mu_n(m, (vector<T__>(l)));
            stan::math::initialize(mu_n, DUMMY_VAR__);
            stan::math::fill(mu_n,DUMMY_VAR__);
            validate_non_negative_index("kappa_n", "m", m);
            validate_non_negative_index("kappa_n", "l", l);
            vector<vector<T__> > kappa_n(m, (vector<T__>(l)));
            stan::math::initialize(kappa_n, DUMMY_VAR__);
            stan::math::fill(kappa_n,DUMMY_VAR__);
            validate_non_negative_index("sigma_n", "m", m);
            validate_non_negative_index("sigma_n", "l", l);
            vector<vector<T__> > sigma_n(m, (vector<T__>(l)));
            stan::math::initialize(sigma_n, DUMMY_VAR__);
            stan::math::fill(sigma_n,DUMMY_VAR__);
            validate_non_negative_index("nu_n", "m", m);
            validate_non_negative_index("nu_n", "l", l);
            vector<vector<T__> > nu_n(m, (vector<T__>(l)));
            stan::math::initialize(nu_n, DUMMY_VAR__);
            stan::math::fill(nu_n,DUMMY_VAR__);
            validate_non_negative_index("t_scale", "m", m);
            validate_non_negative_index("t_scale", "l", l);
            vector<vector<T__> > t_scale(m, (vector<T__>(l)));
            stan::math::initialize(t_scale, DUMMY_VAR__);
            stan::math::fill(t_scale,DUMMY_VAR__);
            validate_non_negative_index("p_test_conj", "m", m);
            validate_non_negative_index("p_test_conj", "n_test", n_test);
            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > p_test_conj(n_test, (Eigen::Matrix<T__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(p_test_conj, DUMMY_VAR__);
            stan::math::fill(p_test_conj,DUMMY_VAR__);
            validate_non_negative_index("log_p_test_conj", "m", m);
            validate_non_negative_index("log_p_test_conj", "n_test", n_test);
            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > log_p_test_conj(n_test, (Eigen::Matrix<T__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(log_p_test_conj, DUMMY_VAR__);
            stan::math::fill(log_p_test_conj,DUMMY_VAR__);


            for (int cat = 1; cat <= m; ++cat) {

                for (int subj = 1; subj <= l; ++subj) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(kappa_n,cat,"kappa_n",1),subj,"kappa_n",2), (kappa_0 + get_base1(get_base1(n_cat,cat,"n_cat",1),subj,"n_cat",2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(nu_n,cat,"nu_n",1),subj,"nu_n",2), (nu_0 + get_base1(get_base1(n_cat,cat,"n_cat",1),subj,"n_cat",2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mu_n,cat,"mu_n",1),subj,"mu_n",2), (((get_base1(mu_0,cat,"mu_0",1) * kappa_0) + (get_base1(get_base1(xbar,cat,"xbar",1),subj,"xbar",2) * get_base1(get_base1(n_cat,cat,"n_cat",1),subj,"n_cat",2))) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),subj,"kappa_n",2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(sigma_n,cat,"sigma_n",1),subj,"sigma_n",2), sqrt(((((nu_0 * pow(get_base1(sigma_0,cat,"sigma_0",1),2)) + get_base1(get_base1(ss,cat,"ss",1),subj,"ss",2)) + (((get_base1(get_base1(n_cat,cat,"n_cat",1),subj,"n_cat",2) * kappa_0) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),subj,"kappa_n",2)) * pow((get_base1(mu_0,cat,"mu_0",1) - get_base1(get_base1(xbar,cat,"xbar",1),subj,"xbar",2)),2))) / get_base1(get_base1(nu_n,cat,"nu_n",1),subj,"nu_n",2))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(t_scale,cat,"t_scale",1),subj,"t_scale",2), (get_base1(get_base1(sigma_n,cat,"sigma_n",1),subj,"sigma_n",2) * sqrt(((get_base1(get_base1(kappa_n,cat,"kappa_n",1),subj,"kappa_n",2) + 1) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),subj,"kappa_n",2)))));
                }
            }
            for (int j = 1; j <= n_test; ++j) {
                {
                int subj(0);
                (void) subj;  // dummy to suppress unused var warning

                stan::math::fill(subj, std::numeric_limits<int>::min());


                stan::math::assign(subj, get_base1(y_test,j,"y_test",1));
                for (int cat = 1; cat <= m; ++cat) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(log_p_test_conj,j,"log_p_test_conj",1),cat,"log_p_test_conj",2), student_t_log(get_base1(x_test,j,"x_test",1),get_base1(get_base1(nu_n,cat,"nu_n",1),subj,"nu_n",2),get_base1(get_base1(mu_n,cat,"mu_n",1),subj,"mu_n",2),get_base1(get_base1(t_scale,cat,"t_scale",1),subj,"t_scale",2)));
                }
                stan::math::assign(get_base1_lhs(p_test_conj,j,"p_test_conj",1), exp(subtract(get_base1(log_p_test_conj,j,"log_p_test_conj",1),log_sum_exp(get_base1(log_p_test_conj,j,"log_p_test_conj",1)))));
                }
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < m; ++i0__) {
                for (int i1__ = 0; i1__ < l; ++i1__) {
                    if (stan::math::is_uninitialized(mu_n[i0__][i1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: mu_n" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < m; ++i0__) {
                for (int i1__ = 0; i1__ < l; ++i1__) {
                    if (stan::math::is_uninitialized(kappa_n[i0__][i1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: kappa_n" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < m; ++i0__) {
                for (int i1__ = 0; i1__ < l; ++i1__) {
                    if (stan::math::is_uninitialized(sigma_n[i0__][i1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: sigma_n" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < m; ++i0__) {
                for (int i1__ = 0; i1__ < l; ++i1__) {
                    if (stan::math::is_uninitialized(nu_n[i0__][i1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: nu_n" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < m; ++i0__) {
                for (int i1__ = 0; i1__ < l; ++i1__) {
                    if (stan::math::is_uninitialized(t_scale[i0__][i1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: t_scale" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_test; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    if (stan::math::is_uninitialized(p_test_conj[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: p_test_conj" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_test; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    if (stan::math::is_uninitialized(log_p_test_conj[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: log_p_test_conj" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"kappa_n[k0__][k1__]",kappa_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"sigma_n[k0__][k1__]",sigma_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"nu_n[k0__][k1__]",nu_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"t_scale[k0__][k1__]",t_scale[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < n_test; ++k0__) {
                stan::math::check_simplex(function__,"p_test_conj[k0__]",p_test_conj[k0__]);
            }

            // model body
            {
            validate_non_negative_index("lapsing_probs", "m", m);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lapsing_probs(static_cast<Eigen::VectorXd::Index>(m));
            (void) lapsing_probs;  // dummy to suppress unused var warning

            stan::math::initialize(lapsing_probs, DUMMY_VAR__);
            stan::math::fill(lapsing_probs,DUMMY_VAR__);


            stan::math::assign(lapsing_probs, rep_vector((lapse_rate / m),m));
            lp_accum__.add(normal_log<propto__>(kappa_0, 0, (n_each * 4)));
            lp_accum__.add(normal_log<propto__>(nu_0, 0, (n_each * 4)));
            lp_accum__.add(normal_log<propto__>(mu_0, 0, 100));
            lp_accum__.add(uniform_log<propto__>(sigma_0, 0, 100));
            for (int i = 1; i <= n_test; ++i) {

                lp_accum__.add(multinomial_log<propto__>(get_base1(z_test_counts,i,"z_test_counts",1), add(multiply(get_base1(p_test_conj,i,"p_test_conj",1),(1 - lapse_rate)),lapsing_probs)));
            }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("kappa_0");
        names__.push_back("nu_0");
        names__.push_back("mu_0");
        names__.push_back("sigma_0");
        names__.push_back("lapse_rate");
        names__.push_back("mu_n");
        names__.push_back("kappa_n");
        names__.push_back("sigma_n");
        names__.push_back("nu_n");
        names__.push_back("t_scale");
        names__.push_back("p_test_conj");
        names__.push_back("log_p_test_conj");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_test);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_test);
        dims__.push_back(m);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_conj_id_lapsing_fit_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double kappa_0 = in__.scalar_lb_constrain(0);
        double nu_0 = in__.scalar_lb_constrain(0);
        vector<double> mu_0;
        size_t dim_mu_0_0__ = m;
        for (size_t k_0__ = 0; k_0__ < dim_mu_0_0__; ++k_0__) {
            mu_0.push_back(in__.scalar_constrain());
        }
        vector<double> sigma_0;
        size_t dim_sigma_0_0__ = m;
        for (size_t k_0__ = 0; k_0__ < dim_sigma_0_0__; ++k_0__) {
            sigma_0.push_back(in__.scalar_lb_constrain(0));
        }
        double lapse_rate = in__.scalar_lub_constrain(0,1);
        vars__.push_back(kappa_0);
        vars__.push_back(nu_0);
            for (int k_0__ = 0; k_0__ < m; ++k_0__) {
            vars__.push_back(mu_0[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < m; ++k_0__) {
            vars__.push_back(sigma_0[k_0__]);
            }
        vars__.push_back(lapse_rate);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("mu_n", "m", m);
            validate_non_negative_index("mu_n", "l", l);
            vector<vector<double> > mu_n(m, (vector<double>(l, 0.0)));
            stan::math::initialize(mu_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_n,DUMMY_VAR__);
            validate_non_negative_index("kappa_n", "m", m);
            validate_non_negative_index("kappa_n", "l", l);
            vector<vector<double> > kappa_n(m, (vector<double>(l, 0.0)));
            stan::math::initialize(kappa_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(kappa_n,DUMMY_VAR__);
            validate_non_negative_index("sigma_n", "m", m);
            validate_non_negative_index("sigma_n", "l", l);
            vector<vector<double> > sigma_n(m, (vector<double>(l, 0.0)));
            stan::math::initialize(sigma_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(sigma_n,DUMMY_VAR__);
            validate_non_negative_index("nu_n", "m", m);
            validate_non_negative_index("nu_n", "l", l);
            vector<vector<double> > nu_n(m, (vector<double>(l, 0.0)));
            stan::math::initialize(nu_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(nu_n,DUMMY_VAR__);
            validate_non_negative_index("t_scale", "m", m);
            validate_non_negative_index("t_scale", "l", l);
            vector<vector<double> > t_scale(m, (vector<double>(l, 0.0)));
            stan::math::initialize(t_scale, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(t_scale,DUMMY_VAR__);
            validate_non_negative_index("p_test_conj", "m", m);
            validate_non_negative_index("p_test_conj", "n_test", n_test);
            vector<vector_d> p_test_conj(n_test, (vector_d(static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(p_test_conj, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(p_test_conj,DUMMY_VAR__);
            validate_non_negative_index("log_p_test_conj", "m", m);
            validate_non_negative_index("log_p_test_conj", "n_test", n_test);
            vector<vector_d> log_p_test_conj(n_test, (vector_d(static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(log_p_test_conj, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_p_test_conj,DUMMY_VAR__);


            for (int cat = 1; cat <= m; ++cat) {

                for (int subj = 1; subj <= l; ++subj) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(kappa_n,cat,"kappa_n",1),subj,"kappa_n",2), (kappa_0 + get_base1(get_base1(n_cat,cat,"n_cat",1),subj,"n_cat",2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(nu_n,cat,"nu_n",1),subj,"nu_n",2), (nu_0 + get_base1(get_base1(n_cat,cat,"n_cat",1),subj,"n_cat",2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mu_n,cat,"mu_n",1),subj,"mu_n",2), (((get_base1(mu_0,cat,"mu_0",1) * kappa_0) + (get_base1(get_base1(xbar,cat,"xbar",1),subj,"xbar",2) * get_base1(get_base1(n_cat,cat,"n_cat",1),subj,"n_cat",2))) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),subj,"kappa_n",2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(sigma_n,cat,"sigma_n",1),subj,"sigma_n",2), sqrt(((((nu_0 * pow(get_base1(sigma_0,cat,"sigma_0",1),2)) + get_base1(get_base1(ss,cat,"ss",1),subj,"ss",2)) + (((get_base1(get_base1(n_cat,cat,"n_cat",1),subj,"n_cat",2) * kappa_0) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),subj,"kappa_n",2)) * pow((get_base1(mu_0,cat,"mu_0",1) - get_base1(get_base1(xbar,cat,"xbar",1),subj,"xbar",2)),2))) / get_base1(get_base1(nu_n,cat,"nu_n",1),subj,"nu_n",2))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(t_scale,cat,"t_scale",1),subj,"t_scale",2), (get_base1(get_base1(sigma_n,cat,"sigma_n",1),subj,"sigma_n",2) * sqrt(((get_base1(get_base1(kappa_n,cat,"kappa_n",1),subj,"kappa_n",2) + 1) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),subj,"kappa_n",2)))));
                }
            }
            for (int j = 1; j <= n_test; ++j) {
                {
                int subj(0);
                (void) subj;  // dummy to suppress unused var warning

                stan::math::fill(subj, std::numeric_limits<int>::min());


                stan::math::assign(subj, get_base1(y_test,j,"y_test",1));
                for (int cat = 1; cat <= m; ++cat) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(log_p_test_conj,j,"log_p_test_conj",1),cat,"log_p_test_conj",2), student_t_log(get_base1(x_test,j,"x_test",1),get_base1(get_base1(nu_n,cat,"nu_n",1),subj,"nu_n",2),get_base1(get_base1(mu_n,cat,"mu_n",1),subj,"mu_n",2),get_base1(get_base1(t_scale,cat,"t_scale",1),subj,"t_scale",2)));
                }
                stan::math::assign(get_base1_lhs(p_test_conj,j,"p_test_conj",1), exp(subtract(get_base1(log_p_test_conj,j,"log_p_test_conj",1),log_sum_exp(get_base1(log_p_test_conj,j,"log_p_test_conj",1)))));
                }
            }

            // validate transformed parameters
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"kappa_n[k0__][k1__]",kappa_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"sigma_n[k0__][k1__]",sigma_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"nu_n[k0__][k1__]",nu_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"t_scale[k0__][k1__]",t_scale[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < n_test; ++k0__) {
                stan::math::check_simplex(function__,"p_test_conj[k0__]",p_test_conj[k0__]);
            }

            // write transformed parameters
            for (int k_1__ = 0; k_1__ < l; ++k_1__) {
                for (int k_0__ = 0; k_0__ < m; ++k_0__) {
                vars__.push_back(mu_n[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < l; ++k_1__) {
                for (int k_0__ = 0; k_0__ < m; ++k_0__) {
                vars__.push_back(kappa_n[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < l; ++k_1__) {
                for (int k_0__ = 0; k_0__ < m; ++k_0__) {
                vars__.push_back(sigma_n[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < l; ++k_1__) {
                for (int k_0__ = 0; k_0__ < m; ++k_0__) {
                vars__.push_back(nu_n[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < l; ++k_1__) {
                for (int k_0__ = 0; k_0__ < m; ++k_0__) {
                vars__.push_back(t_scale[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_test; ++k_0__) {
                vars__.push_back(p_test_conj[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_test; ++k_0__) {
                vars__.push_back(log_p_test_conj[k_0__][k_1__]);
                }
            }

            if (!include_gqs__) return;
            // declare and define generated quantities



            // validate generated quantities

            // write generated quantities
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_conj_id_lapsing_fit";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "kappa_0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu_0";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "lapse_rate";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "kappa_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "sigma_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "nu_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "t_scale" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "log_p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "kappa_0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu_0";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "lapse_rate";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "kappa_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "sigma_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "nu_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "t_scale" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= (m - 1); ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "log_p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_conj_id_lapsing_sufficient_stats_fit_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_conj_id_lapsing_sufficient_stats_fit");
    reader.add_event(119, 119, "end", "model_conj_id_lapsing_sufficient_stats_fit");
    return reader;
}

class model_conj_id_lapsing_sufficient_stats_fit : public prob_grad {
private:
    int m;
    int l;
    matrix_d n;
    matrix_d xbar;
    matrix_d xsd;
    int n_test;
    vector<double> x_test;
    vector<int> y_test;
    vector<vector<int> > z_test_counts;
    double n_each;
    matrix_d ss;
public:
    model_conj_id_lapsing_sufficient_stats_fit(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_conj_id_lapsing_sufficient_stats_fit(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_conj_id_lapsing_sufficient_stats_fit_namespace::model_conj_id_lapsing_sufficient_stats_fit";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "m", "int", context__.to_vec());
            m = int(0);
            vals_i__ = context__.vals_i("m");
            pos__ = 0;
            m = vals_i__[pos__++];
            context__.validate_dims("data initialization", "l", "int", context__.to_vec());
            l = int(0);
            vals_i__ = context__.vals_i("l");
            pos__ = 0;
            l = vals_i__[pos__++];
            validate_non_negative_index("n", "m", m);
            validate_non_negative_index("n", "l", l);
            context__.validate_dims("data initialization", "n", "matrix_d", context__.to_vec(m,l));
            validate_non_negative_index("n", "m", m);
            validate_non_negative_index("n", "l", l);
            n = matrix_d(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(l));
            vals_r__ = context__.vals_r("n");
            pos__ = 0;
            size_t n_m_mat_lim__ = m;
            size_t n_n_mat_lim__ = l;
            for (size_t n_mat__ = 0; n_mat__ < n_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < n_m_mat_lim__; ++m_mat__) {
                    n(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("xbar", "m", m);
            validate_non_negative_index("xbar", "l", l);
            context__.validate_dims("data initialization", "xbar", "matrix_d", context__.to_vec(m,l));
            validate_non_negative_index("xbar", "m", m);
            validate_non_negative_index("xbar", "l", l);
            xbar = matrix_d(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(l));
            vals_r__ = context__.vals_r("xbar");
            pos__ = 0;
            size_t xbar_m_mat_lim__ = m;
            size_t xbar_n_mat_lim__ = l;
            for (size_t n_mat__ = 0; n_mat__ < xbar_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < xbar_m_mat_lim__; ++m_mat__) {
                    xbar(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            validate_non_negative_index("xsd", "m", m);
            validate_non_negative_index("xsd", "l", l);
            context__.validate_dims("data initialization", "xsd", "matrix_d", context__.to_vec(m,l));
            validate_non_negative_index("xsd", "m", m);
            validate_non_negative_index("xsd", "l", l);
            xsd = matrix_d(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(l));
            vals_r__ = context__.vals_r("xsd");
            pos__ = 0;
            size_t xsd_m_mat_lim__ = m;
            size_t xsd_n_mat_lim__ = l;
            for (size_t n_mat__ = 0; n_mat__ < xsd_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < xsd_m_mat_lim__; ++m_mat__) {
                    xsd(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            context__.validate_dims("data initialization", "n_test", "int", context__.to_vec());
            n_test = int(0);
            vals_i__ = context__.vals_i("n_test");
            pos__ = 0;
            n_test = vals_i__[pos__++];
            validate_non_negative_index("x_test", "n_test", n_test);
            context__.validate_dims("data initialization", "x_test", "double", context__.to_vec(n_test));
            validate_non_negative_index("x_test", "n_test", n_test);
            x_test = std::vector<double>(n_test,double(0));
            vals_r__ = context__.vals_r("x_test");
            pos__ = 0;
            size_t x_test_limit_0__ = n_test;
            for (size_t i_0__ = 0; i_0__ < x_test_limit_0__; ++i_0__) {
                x_test[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("y_test", "n_test", n_test);
            context__.validate_dims("data initialization", "y_test", "int", context__.to_vec(n_test));
            validate_non_negative_index("y_test", "n_test", n_test);
            y_test = std::vector<int>(n_test,int(0));
            vals_i__ = context__.vals_i("y_test");
            pos__ = 0;
            size_t y_test_limit_0__ = n_test;
            for (size_t i_0__ = 0; i_0__ < y_test_limit_0__; ++i_0__) {
                y_test[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("z_test_counts", "n_test", n_test);
            validate_non_negative_index("z_test_counts", "m", m);
            context__.validate_dims("data initialization", "z_test_counts", "int", context__.to_vec(n_test,m));
            validate_non_negative_index("z_test_counts", "n_test", n_test);
            validate_non_negative_index("z_test_counts", "m", m);
            z_test_counts = std::vector<std::vector<int> >(n_test,std::vector<int>(m,int(0)));
            vals_i__ = context__.vals_i("z_test_counts");
            pos__ = 0;
            size_t z_test_counts_limit_1__ = m;
            for (size_t i_1__ = 0; i_1__ < z_test_counts_limit_1__; ++i_1__) {
                size_t z_test_counts_limit_0__ = n_test;
                for (size_t i_0__ = 0; i_0__ < z_test_counts_limit_0__; ++i_0__) {
                    z_test_counts[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            // initialize data variables
            n_each = double(0);
            stan::math::fill(n_each,DUMMY_VAR__);
            validate_non_negative_index("ss", "m", m);
            validate_non_negative_index("ss", "l", l);
            ss = matrix_d(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(l));
            stan::math::fill(ss,DUMMY_VAR__);

            stan::math::assign(ss, elt_multiply(subtract(n,1),xsd));
            stan::math::assign(n_each, max(n));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            ++num_params_r__;
            ++num_params_r__;
            validate_non_negative_index("mu_0", "m", m);
            num_params_r__ += m;
            validate_non_negative_index("sigma_0", "m", m);
            num_params_r__ += m;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_conj_id_lapsing_sufficient_stats_fit() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("kappa_0")))
            throw std::runtime_error("variable kappa_0 missing");
        vals_r__ = context__.vals_r("kappa_0");
        pos__ = 0U;
        context__.validate_dims("initialization", "kappa_0", "double", context__.to_vec());
        double kappa_0(0);
        kappa_0 = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,kappa_0);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable kappa_0: ") + e.what());
        }

        if (!(context__.contains_r("nu_0")))
            throw std::runtime_error("variable nu_0 missing");
        vals_r__ = context__.vals_r("nu_0");
        pos__ = 0U;
        context__.validate_dims("initialization", "nu_0", "double", context__.to_vec());
        double nu_0(0);
        nu_0 = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,nu_0);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable nu_0: ") + e.what());
        }

        if (!(context__.contains_r("mu_0")))
            throw std::runtime_error("variable mu_0 missing");
        vals_r__ = context__.vals_r("mu_0");
        pos__ = 0U;
        validate_non_negative_index("mu_0", "m", m);
        context__.validate_dims("initialization", "mu_0", "double", context__.to_vec(m));
        std::vector<double> mu_0(m,double(0));
        for (int i0__ = 0U; i0__ < m; ++i0__)
            mu_0[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < m; ++i0__)
            try {
            writer__.scalar_unconstrain(mu_0[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_0: ") + e.what());
        }

        if (!(context__.contains_r("sigma_0")))
            throw std::runtime_error("variable sigma_0 missing");
        vals_r__ = context__.vals_r("sigma_0");
        pos__ = 0U;
        validate_non_negative_index("sigma_0", "m", m);
        context__.validate_dims("initialization", "sigma_0", "double", context__.to_vec(m));
        std::vector<double> sigma_0(m,double(0));
        for (int i0__ = 0U; i0__ < m; ++i0__)
            sigma_0[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < m; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,sigma_0[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_0: ") + e.what());
        }

        if (!(context__.contains_r("lapse_rate")))
            throw std::runtime_error("variable lapse_rate missing");
        vals_r__ = context__.vals_r("lapse_rate");
        pos__ = 0U;
        context__.validate_dims("initialization", "lapse_rate", "double", context__.to_vec());
        double lapse_rate(0);
        lapse_rate = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,lapse_rate);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lapse_rate: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ kappa_0;
            (void) kappa_0;  // dummy to suppress unused var warning
            if (jacobian__)
                kappa_0 = in__.scalar_lb_constrain(0,lp__);
            else
                kappa_0 = in__.scalar_lb_constrain(0);

            T__ nu_0;
            (void) nu_0;  // dummy to suppress unused var warning
            if (jacobian__)
                nu_0 = in__.scalar_lb_constrain(0,lp__);
            else
                nu_0 = in__.scalar_lb_constrain(0);

            vector<T__> mu_0;
            size_t dim_mu_0_0__ = m;
            mu_0.reserve(dim_mu_0_0__);
            for (size_t k_0__ = 0; k_0__ < dim_mu_0_0__; ++k_0__) {
                if (jacobian__)
                    mu_0.push_back(in__.scalar_constrain(lp__));
                else
                    mu_0.push_back(in__.scalar_constrain());
            }

            vector<T__> sigma_0;
            size_t dim_sigma_0_0__ = m;
            sigma_0.reserve(dim_sigma_0_0__);
            for (size_t k_0__ = 0; k_0__ < dim_sigma_0_0__; ++k_0__) {
                if (jacobian__)
                    sigma_0.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    sigma_0.push_back(in__.scalar_lb_constrain(0));
            }

            T__ lapse_rate;
            (void) lapse_rate;  // dummy to suppress unused var warning
            if (jacobian__)
                lapse_rate = in__.scalar_lub_constrain(0,1,lp__);
            else
                lapse_rate = in__.scalar_lub_constrain(0,1);


            // transformed parameters
            validate_non_negative_index("mu_n", "m", m);
            validate_non_negative_index("mu_n", "l", l);
            vector<vector<T__> > mu_n(m, (vector<T__>(l)));
            stan::math::initialize(mu_n, DUMMY_VAR__);
            stan::math::fill(mu_n,DUMMY_VAR__);
            validate_non_negative_index("kappa_n", "m", m);
            validate_non_negative_index("kappa_n", "l", l);
            vector<vector<T__> > kappa_n(m, (vector<T__>(l)));
            stan::math::initialize(kappa_n, DUMMY_VAR__);
            stan::math::fill(kappa_n,DUMMY_VAR__);
            validate_non_negative_index("sigma_n", "m", m);
            validate_non_negative_index("sigma_n", "l", l);
            vector<vector<T__> > sigma_n(m, (vector<T__>(l)));
            stan::math::initialize(sigma_n, DUMMY_VAR__);
            stan::math::fill(sigma_n,DUMMY_VAR__);
            validate_non_negative_index("nu_n", "m", m);
            validate_non_negative_index("nu_n", "l", l);
            vector<vector<T__> > nu_n(m, (vector<T__>(l)));
            stan::math::initialize(nu_n, DUMMY_VAR__);
            stan::math::fill(nu_n,DUMMY_VAR__);
            validate_non_negative_index("t_scale", "m", m);
            validate_non_negative_index("t_scale", "l", l);
            vector<vector<T__> > t_scale(m, (vector<T__>(l)));
            stan::math::initialize(t_scale, DUMMY_VAR__);
            stan::math::fill(t_scale,DUMMY_VAR__);
            validate_non_negative_index("p_test_conj", "m", m);
            validate_non_negative_index("p_test_conj", "n_test", n_test);
            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > p_test_conj(n_test, (Eigen::Matrix<T__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(p_test_conj, DUMMY_VAR__);
            stan::math::fill(p_test_conj,DUMMY_VAR__);
            validate_non_negative_index("log_p_test_conj", "m", m);
            validate_non_negative_index("log_p_test_conj", "n_test", n_test);
            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > log_p_test_conj(n_test, (Eigen::Matrix<T__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(log_p_test_conj, DUMMY_VAR__);
            stan::math::fill(log_p_test_conj,DUMMY_VAR__);


            for (int cat = 1; cat <= m; ++cat) {

                for (int group = 1; group <= l; ++group) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(kappa_n,cat,"kappa_n",1),group,"kappa_n",2), (kappa_0 + get_base1(n,cat,group,"n",1)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(nu_n,cat,"nu_n",1),group,"nu_n",2), (nu_0 + get_base1(n,cat,group,"n",1)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mu_n,cat,"mu_n",1),group,"mu_n",2), (((get_base1(mu_0,cat,"mu_0",1) * kappa_0) + (get_base1(xbar,cat,group,"xbar",1) * get_base1(n,cat,group,"n",1))) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),group,"kappa_n",2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(sigma_n,cat,"sigma_n",1),group,"sigma_n",2), sqrt(((((nu_0 * pow(get_base1(sigma_0,cat,"sigma_0",1),2)) + get_base1(ss,cat,group,"ss",1)) + (((get_base1(n,cat,group,"n",1) * kappa_0) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),group,"kappa_n",2)) * pow((get_base1(mu_0,cat,"mu_0",1) - get_base1(xbar,cat,group,"xbar",1)),2))) / get_base1(get_base1(nu_n,cat,"nu_n",1),group,"nu_n",2))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(t_scale,cat,"t_scale",1),group,"t_scale",2), (get_base1(get_base1(sigma_n,cat,"sigma_n",1),group,"sigma_n",2) * sqrt(((get_base1(get_base1(kappa_n,cat,"kappa_n",1),group,"kappa_n",2) + 1) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),group,"kappa_n",2)))));
                }
            }
            for (int j = 1; j <= n_test; ++j) {
                {
                int group(0);
                (void) group;  // dummy to suppress unused var warning

                stan::math::fill(group, std::numeric_limits<int>::min());


                stan::math::assign(group, get_base1(y_test,j,"y_test",1));
                for (int cat = 1; cat <= m; ++cat) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(log_p_test_conj,j,"log_p_test_conj",1),cat,"log_p_test_conj",2), student_t_log(get_base1(x_test,j,"x_test",1),get_base1(get_base1(nu_n,cat,"nu_n",1),group,"nu_n",2),get_base1(get_base1(mu_n,cat,"mu_n",1),group,"mu_n",2),get_base1(get_base1(t_scale,cat,"t_scale",1),group,"t_scale",2)));
                }
                stan::math::assign(get_base1_lhs(p_test_conj,j,"p_test_conj",1), exp(subtract(get_base1(log_p_test_conj,j,"log_p_test_conj",1),log_sum_exp(get_base1(log_p_test_conj,j,"log_p_test_conj",1)))));
                }
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < m; ++i0__) {
                for (int i1__ = 0; i1__ < l; ++i1__) {
                    if (stan::math::is_uninitialized(mu_n[i0__][i1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: mu_n" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < m; ++i0__) {
                for (int i1__ = 0; i1__ < l; ++i1__) {
                    if (stan::math::is_uninitialized(kappa_n[i0__][i1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: kappa_n" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < m; ++i0__) {
                for (int i1__ = 0; i1__ < l; ++i1__) {
                    if (stan::math::is_uninitialized(sigma_n[i0__][i1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: sigma_n" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < m; ++i0__) {
                for (int i1__ = 0; i1__ < l; ++i1__) {
                    if (stan::math::is_uninitialized(nu_n[i0__][i1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: nu_n" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < m; ++i0__) {
                for (int i1__ = 0; i1__ < l; ++i1__) {
                    if (stan::math::is_uninitialized(t_scale[i0__][i1__])) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: t_scale" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_test; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    if (stan::math::is_uninitialized(p_test_conj[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: p_test_conj" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_test; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    if (stan::math::is_uninitialized(log_p_test_conj[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: log_p_test_conj" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"kappa_n[k0__][k1__]",kappa_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"sigma_n[k0__][k1__]",sigma_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"nu_n[k0__][k1__]",nu_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"t_scale[k0__][k1__]",t_scale[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < n_test; ++k0__) {
                stan::math::check_simplex(function__,"p_test_conj[k0__]",p_test_conj[k0__]);
            }

            // model body
            {
            validate_non_negative_index("lapsing_probs", "m", m);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  lapsing_probs(static_cast<Eigen::VectorXd::Index>(m));
            (void) lapsing_probs;  // dummy to suppress unused var warning

            stan::math::initialize(lapsing_probs, DUMMY_VAR__);
            stan::math::fill(lapsing_probs,DUMMY_VAR__);


            stan::math::assign(lapsing_probs, rep_vector((lapse_rate / m),m));
            lp_accum__.add(normal_log<propto__>(kappa_0, 0, (n_each * 4)));
            lp_accum__.add(normal_log<propto__>(nu_0, 0, (n_each * 4)));
            lp_accum__.add(normal_log<propto__>(mu_0, 0, 100));
            lp_accum__.add(uniform_log<propto__>(sigma_0, 0, 100));
            for (int i = 1; i <= n_test; ++i) {

                lp_accum__.add(multinomial_log<propto__>(get_base1(z_test_counts,i,"z_test_counts",1), add(multiply(get_base1(p_test_conj,i,"p_test_conj",1),(1 - lapse_rate)),lapsing_probs)));
            }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("kappa_0");
        names__.push_back("nu_0");
        names__.push_back("mu_0");
        names__.push_back("sigma_0");
        names__.push_back("lapse_rate");
        names__.push_back("mu_n");
        names__.push_back("kappa_n");
        names__.push_back("sigma_n");
        names__.push_back("nu_n");
        names__.push_back("t_scale");
        names__.push_back("p_test_conj");
        names__.push_back("log_p_test_conj");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_test);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_test);
        dims__.push_back(m);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_conj_id_lapsing_sufficient_stats_fit_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double kappa_0 = in__.scalar_lb_constrain(0);
        double nu_0 = in__.scalar_lb_constrain(0);
        vector<double> mu_0;
        size_t dim_mu_0_0__ = m;
        for (size_t k_0__ = 0; k_0__ < dim_mu_0_0__; ++k_0__) {
            mu_0.push_back(in__.scalar_constrain());
        }
        vector<double> sigma_0;
        size_t dim_sigma_0_0__ = m;
        for (size_t k_0__ = 0; k_0__ < dim_sigma_0_0__; ++k_0__) {
            sigma_0.push_back(in__.scalar_lb_constrain(0));
        }
        double lapse_rate = in__.scalar_lub_constrain(0,1);
        vars__.push_back(kappa_0);
        vars__.push_back(nu_0);
            for (int k_0__ = 0; k_0__ < m; ++k_0__) {
            vars__.push_back(mu_0[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < m; ++k_0__) {
            vars__.push_back(sigma_0[k_0__]);
            }
        vars__.push_back(lapse_rate);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("mu_n", "m", m);
            validate_non_negative_index("mu_n", "l", l);
            vector<vector<double> > mu_n(m, (vector<double>(l, 0.0)));
            stan::math::initialize(mu_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_n,DUMMY_VAR__);
            validate_non_negative_index("kappa_n", "m", m);
            validate_non_negative_index("kappa_n", "l", l);
            vector<vector<double> > kappa_n(m, (vector<double>(l, 0.0)));
            stan::math::initialize(kappa_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(kappa_n,DUMMY_VAR__);
            validate_non_negative_index("sigma_n", "m", m);
            validate_non_negative_index("sigma_n", "l", l);
            vector<vector<double> > sigma_n(m, (vector<double>(l, 0.0)));
            stan::math::initialize(sigma_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(sigma_n,DUMMY_VAR__);
            validate_non_negative_index("nu_n", "m", m);
            validate_non_negative_index("nu_n", "l", l);
            vector<vector<double> > nu_n(m, (vector<double>(l, 0.0)));
            stan::math::initialize(nu_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(nu_n,DUMMY_VAR__);
            validate_non_negative_index("t_scale", "m", m);
            validate_non_negative_index("t_scale", "l", l);
            vector<vector<double> > t_scale(m, (vector<double>(l, 0.0)));
            stan::math::initialize(t_scale, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(t_scale,DUMMY_VAR__);
            validate_non_negative_index("p_test_conj", "m", m);
            validate_non_negative_index("p_test_conj", "n_test", n_test);
            vector<vector_d> p_test_conj(n_test, (vector_d(static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(p_test_conj, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(p_test_conj,DUMMY_VAR__);
            validate_non_negative_index("log_p_test_conj", "m", m);
            validate_non_negative_index("log_p_test_conj", "n_test", n_test);
            vector<vector_d> log_p_test_conj(n_test, (vector_d(static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(log_p_test_conj, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_p_test_conj,DUMMY_VAR__);


            for (int cat = 1; cat <= m; ++cat) {

                for (int group = 1; group <= l; ++group) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(kappa_n,cat,"kappa_n",1),group,"kappa_n",2), (kappa_0 + get_base1(n,cat,group,"n",1)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(nu_n,cat,"nu_n",1),group,"nu_n",2), (nu_0 + get_base1(n,cat,group,"n",1)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(mu_n,cat,"mu_n",1),group,"mu_n",2), (((get_base1(mu_0,cat,"mu_0",1) * kappa_0) + (get_base1(xbar,cat,group,"xbar",1) * get_base1(n,cat,group,"n",1))) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),group,"kappa_n",2)));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(sigma_n,cat,"sigma_n",1),group,"sigma_n",2), sqrt(((((nu_0 * pow(get_base1(sigma_0,cat,"sigma_0",1),2)) + get_base1(ss,cat,group,"ss",1)) + (((get_base1(n,cat,group,"n",1) * kappa_0) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),group,"kappa_n",2)) * pow((get_base1(mu_0,cat,"mu_0",1) - get_base1(xbar,cat,group,"xbar",1)),2))) / get_base1(get_base1(nu_n,cat,"nu_n",1),group,"nu_n",2))));
                    stan::math::assign(get_base1_lhs(get_base1_lhs(t_scale,cat,"t_scale",1),group,"t_scale",2), (get_base1(get_base1(sigma_n,cat,"sigma_n",1),group,"sigma_n",2) * sqrt(((get_base1(get_base1(kappa_n,cat,"kappa_n",1),group,"kappa_n",2) + 1) / get_base1(get_base1(kappa_n,cat,"kappa_n",1),group,"kappa_n",2)))));
                }
            }
            for (int j = 1; j <= n_test; ++j) {
                {
                int group(0);
                (void) group;  // dummy to suppress unused var warning

                stan::math::fill(group, std::numeric_limits<int>::min());


                stan::math::assign(group, get_base1(y_test,j,"y_test",1));
                for (int cat = 1; cat <= m; ++cat) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(log_p_test_conj,j,"log_p_test_conj",1),cat,"log_p_test_conj",2), student_t_log(get_base1(x_test,j,"x_test",1),get_base1(get_base1(nu_n,cat,"nu_n",1),group,"nu_n",2),get_base1(get_base1(mu_n,cat,"mu_n",1),group,"mu_n",2),get_base1(get_base1(t_scale,cat,"t_scale",1),group,"t_scale",2)));
                }
                stan::math::assign(get_base1_lhs(p_test_conj,j,"p_test_conj",1), exp(subtract(get_base1(log_p_test_conj,j,"log_p_test_conj",1),log_sum_exp(get_base1(log_p_test_conj,j,"log_p_test_conj",1)))));
                }
            }

            // validate transformed parameters
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"kappa_n[k0__][k1__]",kappa_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"sigma_n[k0__][k1__]",sigma_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"nu_n[k0__][k1__]",nu_n[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < m; ++k0__) {
                for (int k1__ = 0; k1__ < l; ++k1__) {
                    check_greater_or_equal(function__,"t_scale[k0__][k1__]",t_scale[k0__][k1__],0);
                }
            }
            for (int k0__ = 0; k0__ < n_test; ++k0__) {
                stan::math::check_simplex(function__,"p_test_conj[k0__]",p_test_conj[k0__]);
            }

            // write transformed parameters
            for (int k_1__ = 0; k_1__ < l; ++k_1__) {
                for (int k_0__ = 0; k_0__ < m; ++k_0__) {
                vars__.push_back(mu_n[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < l; ++k_1__) {
                for (int k_0__ = 0; k_0__ < m; ++k_0__) {
                vars__.push_back(kappa_n[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < l; ++k_1__) {
                for (int k_0__ = 0; k_0__ < m; ++k_0__) {
                vars__.push_back(sigma_n[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < l; ++k_1__) {
                for (int k_0__ = 0; k_0__ < m; ++k_0__) {
                vars__.push_back(nu_n[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < l; ++k_1__) {
                for (int k_0__ = 0; k_0__ < m; ++k_0__) {
                vars__.push_back(t_scale[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_test; ++k_0__) {
                vars__.push_back(p_test_conj[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_test; ++k_0__) {
                vars__.push_back(log_p_test_conj[k_0__][k_1__]);
                }
            }

            if (!include_gqs__) return;
            // declare and define generated quantities



            // validate generated quantities

            // write generated quantities
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_conj_id_lapsing_sufficient_stats_fit";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "kappa_0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu_0";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "lapse_rate";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "kappa_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "sigma_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "nu_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "t_scale" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "log_p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "kappa_0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu_0";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "lapse_rate";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "kappa_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "sigma_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "nu_n" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= l; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "t_scale" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= (m - 1); ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "log_p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_conj_id_lapsing_sufficient_stats_incremental_fit_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_conj_id_lapsing_sufficient_stats_incremental_fit");
    reader.add_event(133, 133, "end", "model_conj_id_lapsing_sufficient_stats_incremental_fit");
    return reader;
}

class model_conj_id_lapsing_sufficient_stats_incremental_fit : public prob_grad {
private:
    int m;
    int l;
    int k;
    vector<matrix_d> n;
    vector<matrix_d> xbar;
    vector<matrix_d> xsd;
    int n_test;
    vector<double> x_test;
    vector<int> y_test;
    vector<int> block_test;
    vector<vector<int> > z_test_counts;
    vector<double> block_max_n;
    double n_each;
    vector<matrix_d> ss;
public:
    model_conj_id_lapsing_sufficient_stats_incremental_fit(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_conj_id_lapsing_sufficient_stats_incremental_fit(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_conj_id_lapsing_sufficient_stats_incremental_fit_namespace::model_conj_id_lapsing_sufficient_stats_incremental_fit";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "m", "int", context__.to_vec());
            m = int(0);
            vals_i__ = context__.vals_i("m");
            pos__ = 0;
            m = vals_i__[pos__++];
            context__.validate_dims("data initialization", "l", "int", context__.to_vec());
            l = int(0);
            vals_i__ = context__.vals_i("l");
            pos__ = 0;
            l = vals_i__[pos__++];
            context__.validate_dims("data initialization", "k", "int", context__.to_vec());
            k = int(0);
            vals_i__ = context__.vals_i("k");
            pos__ = 0;
            k = vals_i__[pos__++];
            validate_non_negative_index("n", "k", k);
            validate_non_negative_index("n", "m", m);
            validate_non_negative_index("n", "l", l);
            context__.validate_dims("data initialization", "n", "matrix_d", context__.to_vec(k,m,l));
            validate_non_negative_index("n", "k", k);
            validate_non_negative_index("n", "m", m);
            validate_non_negative_index("n", "l", l);
            n = std::vector<matrix_d>(k,matrix_d(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(l)));
            vals_r__ = context__.vals_r("n");
            pos__ = 0;
            size_t n_m_mat_lim__ = m;
            size_t n_n_mat_lim__ = l;
            for (size_t n_mat__ = 0; n_mat__ < n_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < n_m_mat_lim__; ++m_mat__) {
                    size_t n_limit_0__ = k;
                    for (size_t i_0__ = 0; i_0__ < n_limit_0__; ++i_0__) {
                        n[i_0__](m_mat__,n_mat__) = vals_r__[pos__++];
            }
                }
            }
            validate_non_negative_index("xbar", "k", k);
            validate_non_negative_index("xbar", "m", m);
            validate_non_negative_index("xbar", "l", l);
            context__.validate_dims("data initialization", "xbar", "matrix_d", context__.to_vec(k,m,l));
            validate_non_negative_index("xbar", "k", k);
            validate_non_negative_index("xbar", "m", m);
            validate_non_negative_index("xbar", "l", l);
            xbar = std::vector<matrix_d>(k,matrix_d(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(l)));
            vals_r__ = context__.vals_r("xbar");
            pos__ = 0;
            size_t xbar_m_mat_lim__ = m;
            size_t xbar_n_mat_lim__ = l;
            for (size_t n_mat__ = 0; n_mat__ < xbar_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < xbar_m_mat_lim__; ++m_mat__) {
                    size_t xbar_limit_0__ = k;
                    for (size_t i_0__ = 0; i_0__ < xbar_limit_0__; ++i_0__) {
                        xbar[i_0__](m_mat__,n_mat__) = vals_r__[pos__++];
            }
                }
            }
            validate_non_negative_index("xsd", "k", k);
            validate_non_negative_index("xsd", "m", m);
            validate_non_negative_index("xsd", "l", l);
            context__.validate_dims("data initialization", "xsd", "matrix_d", context__.to_vec(k,m,l));
            validate_non_negative_index("xsd", "k", k);
            validate_non_negative_index("xsd", "m", m);
            validate_non_negative_index("xsd", "l", l);
            xsd = std::vector<matrix_d>(k,matrix_d(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(l)));
            vals_r__ = context__.vals_r("xsd");
            pos__ = 0;
            size_t xsd_m_mat_lim__ = m;
            size_t xsd_n_mat_lim__ = l;
            for (size_t n_mat__ = 0; n_mat__ < xsd_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < xsd_m_mat_lim__; ++m_mat__) {
                    size_t xsd_limit_0__ = k;
                    for (size_t i_0__ = 0; i_0__ < xsd_limit_0__; ++i_0__) {
                        xsd[i_0__](m_mat__,n_mat__) = vals_r__[pos__++];
            }
                }
            }
            context__.validate_dims("data initialization", "n_test", "int", context__.to_vec());
            n_test = int(0);
            vals_i__ = context__.vals_i("n_test");
            pos__ = 0;
            n_test = vals_i__[pos__++];
            validate_non_negative_index("x_test", "n_test", n_test);
            context__.validate_dims("data initialization", "x_test", "double", context__.to_vec(n_test));
            validate_non_negative_index("x_test", "n_test", n_test);
            x_test = std::vector<double>(n_test,double(0));
            vals_r__ = context__.vals_r("x_test");
            pos__ = 0;
            size_t x_test_limit_0__ = n_test;
            for (size_t i_0__ = 0; i_0__ < x_test_limit_0__; ++i_0__) {
                x_test[i_0__] = vals_r__[pos__++];
            }
            validate_non_negative_index("y_test", "n_test", n_test);
            context__.validate_dims("data initialization", "y_test", "int", context__.to_vec(n_test));
            validate_non_negative_index("y_test", "n_test", n_test);
            y_test = std::vector<int>(n_test,int(0));
            vals_i__ = context__.vals_i("y_test");
            pos__ = 0;
            size_t y_test_limit_0__ = n_test;
            for (size_t i_0__ = 0; i_0__ < y_test_limit_0__; ++i_0__) {
                y_test[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("block_test", "n_test", n_test);
            context__.validate_dims("data initialization", "block_test", "int", context__.to_vec(n_test));
            validate_non_negative_index("block_test", "n_test", n_test);
            block_test = std::vector<int>(n_test,int(0));
            vals_i__ = context__.vals_i("block_test");
            pos__ = 0;
            size_t block_test_limit_0__ = n_test;
            for (size_t i_0__ = 0; i_0__ < block_test_limit_0__; ++i_0__) {
                block_test[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("z_test_counts", "n_test", n_test);
            validate_non_negative_index("z_test_counts", "m", m);
            context__.validate_dims("data initialization", "z_test_counts", "int", context__.to_vec(n_test,m));
            validate_non_negative_index("z_test_counts", "n_test", n_test);
            validate_non_negative_index("z_test_counts", "m", m);
            z_test_counts = std::vector<std::vector<int> >(n_test,std::vector<int>(m,int(0)));
            vals_i__ = context__.vals_i("z_test_counts");
            pos__ = 0;
            size_t z_test_counts_limit_1__ = m;
            for (size_t i_1__ = 0; i_1__ < z_test_counts_limit_1__; ++i_1__) {
                size_t z_test_counts_limit_0__ = n_test;
                for (size_t i_0__ = 0; i_0__ < z_test_counts_limit_0__; ++i_0__) {
                    z_test_counts[i_0__][i_1__] = vals_i__[pos__++];
                }
            }

            // validate, data variables
            // initialize data variables
            validate_non_negative_index("block_max_n", "k", k);
            block_max_n = std::vector<double>(k,double(0));
            stan::math::fill(block_max_n,DUMMY_VAR__);
            n_each = double(0);
            stan::math::fill(n_each,DUMMY_VAR__);
            validate_non_negative_index("ss", "k", k);
            validate_non_negative_index("ss", "m", m);
            validate_non_negative_index("ss", "l", l);
            ss = std::vector<matrix_d>(k,matrix_d(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(l)));
            stan::math::fill(ss,DUMMY_VAR__);

            for (int block = 1; block <= k; ++block) {

                stan::math::assign(get_base1_lhs(ss,block,"ss",1), elt_multiply(subtract(get_base1(n,block,"n",1),1),get_base1(xsd,block,"xsd",1)));
                stan::math::assign(get_base1_lhs(block_max_n,block,"block_max_n",1), max(get_base1(n,block,"n",1)));
            }
            stan::math::assign(n_each, max(block_max_n));

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            ++num_params_r__;
            ++num_params_r__;
            validate_non_negative_index("mu_0", "m", m);
            num_params_r__ += m;
            validate_non_negative_index("sigma_0", "m", m);
            num_params_r__ += m;
            validate_non_negative_index("lapse_rate", "k", k);
            num_params_r__ += k;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_conj_id_lapsing_sufficient_stats_incremental_fit() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("kappa_0")))
            throw std::runtime_error("variable kappa_0 missing");
        vals_r__ = context__.vals_r("kappa_0");
        pos__ = 0U;
        context__.validate_dims("initialization", "kappa_0", "double", context__.to_vec());
        double kappa_0(0);
        kappa_0 = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,kappa_0);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable kappa_0: ") + e.what());
        }

        if (!(context__.contains_r("nu_0")))
            throw std::runtime_error("variable nu_0 missing");
        vals_r__ = context__.vals_r("nu_0");
        pos__ = 0U;
        context__.validate_dims("initialization", "nu_0", "double", context__.to_vec());
        double nu_0(0);
        nu_0 = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,nu_0);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable nu_0: ") + e.what());
        }

        if (!(context__.contains_r("mu_0")))
            throw std::runtime_error("variable mu_0 missing");
        vals_r__ = context__.vals_r("mu_0");
        pos__ = 0U;
        validate_non_negative_index("mu_0", "m", m);
        context__.validate_dims("initialization", "mu_0", "double", context__.to_vec(m));
        std::vector<double> mu_0(m,double(0));
        for (int i0__ = 0U; i0__ < m; ++i0__)
            mu_0[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < m; ++i0__)
            try {
            writer__.scalar_unconstrain(mu_0[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_0: ") + e.what());
        }

        if (!(context__.contains_r("sigma_0")))
            throw std::runtime_error("variable sigma_0 missing");
        vals_r__ = context__.vals_r("sigma_0");
        pos__ = 0U;
        validate_non_negative_index("sigma_0", "m", m);
        context__.validate_dims("initialization", "sigma_0", "double", context__.to_vec(m));
        std::vector<double> sigma_0(m,double(0));
        for (int i0__ = 0U; i0__ < m; ++i0__)
            sigma_0[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < m; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,sigma_0[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_0: ") + e.what());
        }

        if (!(context__.contains_r("lapse_rate")))
            throw std::runtime_error("variable lapse_rate missing");
        vals_r__ = context__.vals_r("lapse_rate");
        pos__ = 0U;
        validate_non_negative_index("lapse_rate", "k", k);
        context__.validate_dims("initialization", "lapse_rate", "double", context__.to_vec(k));
        std::vector<double> lapse_rate(k,double(0));
        for (int i0__ = 0U; i0__ < k; ++i0__)
            lapse_rate[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < k; ++i0__)
            try {
            writer__.scalar_lub_unconstrain(0,1,lapse_rate[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lapse_rate: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            T__ kappa_0;
            (void) kappa_0;  // dummy to suppress unused var warning
            if (jacobian__)
                kappa_0 = in__.scalar_lb_constrain(0,lp__);
            else
                kappa_0 = in__.scalar_lb_constrain(0);

            T__ nu_0;
            (void) nu_0;  // dummy to suppress unused var warning
            if (jacobian__)
                nu_0 = in__.scalar_lb_constrain(0,lp__);
            else
                nu_0 = in__.scalar_lb_constrain(0);

            vector<T__> mu_0;
            size_t dim_mu_0_0__ = m;
            mu_0.reserve(dim_mu_0_0__);
            for (size_t k_0__ = 0; k_0__ < dim_mu_0_0__; ++k_0__) {
                if (jacobian__)
                    mu_0.push_back(in__.scalar_constrain(lp__));
                else
                    mu_0.push_back(in__.scalar_constrain());
            }

            vector<T__> sigma_0;
            size_t dim_sigma_0_0__ = m;
            sigma_0.reserve(dim_sigma_0_0__);
            for (size_t k_0__ = 0; k_0__ < dim_sigma_0_0__; ++k_0__) {
                if (jacobian__)
                    sigma_0.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    sigma_0.push_back(in__.scalar_lb_constrain(0));
            }

            vector<T__> lapse_rate;
            size_t dim_lapse_rate_0__ = k;
            lapse_rate.reserve(dim_lapse_rate_0__);
            for (size_t k_0__ = 0; k_0__ < dim_lapse_rate_0__; ++k_0__) {
                if (jacobian__)
                    lapse_rate.push_back(in__.scalar_lub_constrain(0,1,lp__));
                else
                    lapse_rate.push_back(in__.scalar_lub_constrain(0,1));
            }


            // transformed parameters
            validate_non_negative_index("mu_n", "k", k);
            validate_non_negative_index("mu_n", "m", m);
            validate_non_negative_index("mu_n", "l", l);
            vector<vector<vector<T__> > > mu_n(k, (vector<vector<T__> >(m, (vector<T__>(l)))));
            stan::math::initialize(mu_n, DUMMY_VAR__);
            stan::math::fill(mu_n,DUMMY_VAR__);
            validate_non_negative_index("kappa_n", "k", k);
            validate_non_negative_index("kappa_n", "m", m);
            validate_non_negative_index("kappa_n", "l", l);
            vector<vector<vector<T__> > > kappa_n(k, (vector<vector<T__> >(m, (vector<T__>(l)))));
            stan::math::initialize(kappa_n, DUMMY_VAR__);
            stan::math::fill(kappa_n,DUMMY_VAR__);
            validate_non_negative_index("sigma_n", "k", k);
            validate_non_negative_index("sigma_n", "m", m);
            validate_non_negative_index("sigma_n", "l", l);
            vector<vector<vector<T__> > > sigma_n(k, (vector<vector<T__> >(m, (vector<T__>(l)))));
            stan::math::initialize(sigma_n, DUMMY_VAR__);
            stan::math::fill(sigma_n,DUMMY_VAR__);
            validate_non_negative_index("nu_n", "k", k);
            validate_non_negative_index("nu_n", "m", m);
            validate_non_negative_index("nu_n", "l", l);
            vector<vector<vector<T__> > > nu_n(k, (vector<vector<T__> >(m, (vector<T__>(l)))));
            stan::math::initialize(nu_n, DUMMY_VAR__);
            stan::math::fill(nu_n,DUMMY_VAR__);
            validate_non_negative_index("t_scale", "k", k);
            validate_non_negative_index("t_scale", "m", m);
            validate_non_negative_index("t_scale", "l", l);
            vector<vector<vector<T__> > > t_scale(k, (vector<vector<T__> >(m, (vector<T__>(l)))));
            stan::math::initialize(t_scale, DUMMY_VAR__);
            stan::math::fill(t_scale,DUMMY_VAR__);
            validate_non_negative_index("p_test_conj", "m", m);
            validate_non_negative_index("p_test_conj", "n_test", n_test);
            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > p_test_conj(n_test, (Eigen::Matrix<T__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(p_test_conj, DUMMY_VAR__);
            stan::math::fill(p_test_conj,DUMMY_VAR__);
            validate_non_negative_index("log_p_test_conj", "m", m);
            validate_non_negative_index("log_p_test_conj", "n_test", n_test);
            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > log_p_test_conj(n_test, (Eigen::Matrix<T__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(log_p_test_conj, DUMMY_VAR__);
            stan::math::fill(log_p_test_conj,DUMMY_VAR__);


            for (int cat = 1; cat <= m; ++cat) {

                for (int group = 1; group <= l; ++group) {

                    for (int block = 1; block <= k; ++block) {

                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(kappa_n,block,"kappa_n",1),cat,"kappa_n",2),group,"kappa_n",3), (kappa_0 + get_base1(get_base1(n,block,"n",1),cat,group,"n",2)));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(nu_n,block,"nu_n",1),cat,"nu_n",2),group,"nu_n",3), (nu_0 + get_base1(get_base1(n,block,"n",1),cat,group,"n",2)));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mu_n,block,"mu_n",1),cat,"mu_n",2),group,"mu_n",3), (((get_base1(mu_0,cat,"mu_0",1) * kappa_0) + (get_base1(get_base1(xbar,block,"xbar",1),cat,group,"xbar",2) * get_base1(get_base1(n,block,"n",1),cat,group,"n",2))) / get_base1(get_base1(get_base1(kappa_n,block,"kappa_n",1),cat,"kappa_n",2),group,"kappa_n",3)));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(sigma_n,block,"sigma_n",1),cat,"sigma_n",2),group,"sigma_n",3), sqrt(((((nu_0 * pow(get_base1(sigma_0,cat,"sigma_0",1),2)) + get_base1(get_base1(ss,block,"ss",1),cat,group,"ss",2)) + (((get_base1(get_base1(n,block,"n",1),cat,group,"n",2) * kappa_0) / get_base1(get_base1(get_base1(kappa_n,block,"kappa_n",1),cat,"kappa_n",2),group,"kappa_n",3)) * pow((get_base1(mu_0,cat,"mu_0",1) - get_base1(get_base1(xbar,block,"xbar",1),cat,group,"xbar",2)),2))) / get_base1(get_base1(get_base1(nu_n,block,"nu_n",1),cat,"nu_n",2),group,"nu_n",3))));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(t_scale,block,"t_scale",1),cat,"t_scale",2),group,"t_scale",3), (get_base1(get_base1(get_base1(sigma_n,block,"sigma_n",1),cat,"sigma_n",2),group,"sigma_n",3) * sqrt(((get_base1(get_base1(get_base1(kappa_n,block,"kappa_n",1),cat,"kappa_n",2),group,"kappa_n",3) + 1) / get_base1(get_base1(get_base1(kappa_n,block,"kappa_n",1),cat,"kappa_n",2),group,"kappa_n",3)))));
                    }
                }
            }
            for (int j = 1; j <= n_test; ++j) {
                {
                int group(0);
                (void) group;  // dummy to suppress unused var warning

                stan::math::fill(group, std::numeric_limits<int>::min());
                int blck(0);
                (void) blck;  // dummy to suppress unused var warning

                stan::math::fill(blck, std::numeric_limits<int>::min());


                stan::math::assign(group, get_base1(y_test,j,"y_test",1));
                stan::math::assign(blck, get_base1(block_test,j,"block_test",1));
                for (int cat = 1; cat <= m; ++cat) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(log_p_test_conj,j,"log_p_test_conj",1),cat,"log_p_test_conj",2), student_t_log(get_base1(x_test,j,"x_test",1),get_base1(get_base1(get_base1(nu_n,blck,"nu_n",1),cat,"nu_n",2),group,"nu_n",3),get_base1(get_base1(get_base1(mu_n,blck,"mu_n",1),cat,"mu_n",2),group,"mu_n",3),get_base1(get_base1(get_base1(t_scale,blck,"t_scale",1),cat,"t_scale",2),group,"t_scale",3)));
                }
                stan::math::assign(get_base1_lhs(p_test_conj,j,"p_test_conj",1), exp(subtract(get_base1(log_p_test_conj,j,"log_p_test_conj",1),log_sum_exp(get_base1(log_p_test_conj,j,"log_p_test_conj",1)))));
                }
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < k; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    for (int i2__ = 0; i2__ < l; ++i2__) {
                        if (stan::math::is_uninitialized(mu_n[i0__][i1__][i2__])) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: mu_n" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < k; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    for (int i2__ = 0; i2__ < l; ++i2__) {
                        if (stan::math::is_uninitialized(kappa_n[i0__][i1__][i2__])) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: kappa_n" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < k; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    for (int i2__ = 0; i2__ < l; ++i2__) {
                        if (stan::math::is_uninitialized(sigma_n[i0__][i1__][i2__])) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: sigma_n" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < k; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    for (int i2__ = 0; i2__ < l; ++i2__) {
                        if (stan::math::is_uninitialized(nu_n[i0__][i1__][i2__])) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: nu_n" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < k; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    for (int i2__ = 0; i2__ < l; ++i2__) {
                        if (stan::math::is_uninitialized(t_scale[i0__][i1__][i2__])) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: t_scale" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_test; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    if (stan::math::is_uninitialized(p_test_conj[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: p_test_conj" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_test; ++i0__) {
                for (int i1__ = 0; i1__ < m; ++i1__) {
                    if (stan::math::is_uninitialized(log_p_test_conj[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: log_p_test_conj" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            for (int k0__ = 0; k0__ < k; ++k0__) {
                for (int k1__ = 0; k1__ < m; ++k1__) {
                    for (int k2__ = 0; k2__ < l; ++k2__) {
                        check_greater_or_equal(function__,"kappa_n[k0__][k1__][k2__]",kappa_n[k0__][k1__][k2__],0);
                    }
                }
            }
            for (int k0__ = 0; k0__ < k; ++k0__) {
                for (int k1__ = 0; k1__ < m; ++k1__) {
                    for (int k2__ = 0; k2__ < l; ++k2__) {
                        check_greater_or_equal(function__,"sigma_n[k0__][k1__][k2__]",sigma_n[k0__][k1__][k2__],0);
                    }
                }
            }
            for (int k0__ = 0; k0__ < k; ++k0__) {
                for (int k1__ = 0; k1__ < m; ++k1__) {
                    for (int k2__ = 0; k2__ < l; ++k2__) {
                        check_greater_or_equal(function__,"nu_n[k0__][k1__][k2__]",nu_n[k0__][k1__][k2__],0);
                    }
                }
            }
            for (int k0__ = 0; k0__ < k; ++k0__) {
                for (int k1__ = 0; k1__ < m; ++k1__) {
                    for (int k2__ = 0; k2__ < l; ++k2__) {
                        check_greater_or_equal(function__,"t_scale[k0__][k1__][k2__]",t_scale[k0__][k1__][k2__],0);
                    }
                }
            }
            for (int k0__ = 0; k0__ < n_test; ++k0__) {
                stan::math::check_simplex(function__,"p_test_conj[k0__]",p_test_conj[k0__]);
            }

            // model body
            {
            validate_non_negative_index("lapsing_probs", "m", m);
            validate_non_negative_index("lapsing_probs", "k", k);
            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > lapsing_probs(k, (Eigen::Matrix<T__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(lapsing_probs, DUMMY_VAR__);
            stan::math::fill(lapsing_probs,DUMMY_VAR__);


            for (int block = 1; block <= k; ++block) {

                stan::math::assign(get_base1_lhs(lapsing_probs,block,"lapsing_probs",1), rep_vector((get_base1(lapse_rate,block,"lapse_rate",1) / m),m));
            }
            lp_accum__.add(normal_log<propto__>(kappa_0, 0, (n_each * 4)));
            lp_accum__.add(normal_log<propto__>(nu_0, 0, (n_each * 4)));
            lp_accum__.add(normal_log<propto__>(mu_0, 0, 100));
            lp_accum__.add(uniform_log<propto__>(sigma_0, 0, 100));
            for (int i = 1; i <= n_test; ++i) {
                {
                int blck(0);
                (void) blck;  // dummy to suppress unused var warning

                stan::math::fill(blck, std::numeric_limits<int>::min());
                stan::math::assign(blck,get_base1(block_test,i,"block_test",1));


                lp_accum__.add(multinomial_log<propto__>(get_base1(z_test_counts,i,"z_test_counts",1), add(multiply(get_base1(p_test_conj,i,"p_test_conj",1),(1 - get_base1(lapse_rate,blck,"lapse_rate",1))),get_base1(lapsing_probs,blck,"lapsing_probs",1))));
                }
            }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("kappa_0");
        names__.push_back("nu_0");
        names__.push_back("mu_0");
        names__.push_back("sigma_0");
        names__.push_back("lapse_rate");
        names__.push_back("mu_n");
        names__.push_back("kappa_n");
        names__.push_back("sigma_n");
        names__.push_back("nu_n");
        names__.push_back("t_scale");
        names__.push_back("p_test_conj");
        names__.push_back("log_p_test_conj");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(k);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(k);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(k);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(k);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(k);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(k);
        dims__.push_back(m);
        dims__.push_back(l);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_test);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_test);
        dims__.push_back(m);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_conj_id_lapsing_sufficient_stats_incremental_fit_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double kappa_0 = in__.scalar_lb_constrain(0);
        double nu_0 = in__.scalar_lb_constrain(0);
        vector<double> mu_0;
        size_t dim_mu_0_0__ = m;
        for (size_t k_0__ = 0; k_0__ < dim_mu_0_0__; ++k_0__) {
            mu_0.push_back(in__.scalar_constrain());
        }
        vector<double> sigma_0;
        size_t dim_sigma_0_0__ = m;
        for (size_t k_0__ = 0; k_0__ < dim_sigma_0_0__; ++k_0__) {
            sigma_0.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> lapse_rate;
        size_t dim_lapse_rate_0__ = k;
        for (size_t k_0__ = 0; k_0__ < dim_lapse_rate_0__; ++k_0__) {
            lapse_rate.push_back(in__.scalar_lub_constrain(0,1));
        }
        vars__.push_back(kappa_0);
        vars__.push_back(nu_0);
            for (int k_0__ = 0; k_0__ < m; ++k_0__) {
            vars__.push_back(mu_0[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < m; ++k_0__) {
            vars__.push_back(sigma_0[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < k; ++k_0__) {
            vars__.push_back(lapse_rate[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("mu_n", "k", k);
            validate_non_negative_index("mu_n", "m", m);
            validate_non_negative_index("mu_n", "l", l);
            vector<vector<vector<double> > > mu_n(k, (vector<vector<double> >(m, (vector<double>(l, 0.0)))));
            stan::math::initialize(mu_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_n,DUMMY_VAR__);
            validate_non_negative_index("kappa_n", "k", k);
            validate_non_negative_index("kappa_n", "m", m);
            validate_non_negative_index("kappa_n", "l", l);
            vector<vector<vector<double> > > kappa_n(k, (vector<vector<double> >(m, (vector<double>(l, 0.0)))));
            stan::math::initialize(kappa_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(kappa_n,DUMMY_VAR__);
            validate_non_negative_index("sigma_n", "k", k);
            validate_non_negative_index("sigma_n", "m", m);
            validate_non_negative_index("sigma_n", "l", l);
            vector<vector<vector<double> > > sigma_n(k, (vector<vector<double> >(m, (vector<double>(l, 0.0)))));
            stan::math::initialize(sigma_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(sigma_n,DUMMY_VAR__);
            validate_non_negative_index("nu_n", "k", k);
            validate_non_negative_index("nu_n", "m", m);
            validate_non_negative_index("nu_n", "l", l);
            vector<vector<vector<double> > > nu_n(k, (vector<vector<double> >(m, (vector<double>(l, 0.0)))));
            stan::math::initialize(nu_n, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(nu_n,DUMMY_VAR__);
            validate_non_negative_index("t_scale", "k", k);
            validate_non_negative_index("t_scale", "m", m);
            validate_non_negative_index("t_scale", "l", l);
            vector<vector<vector<double> > > t_scale(k, (vector<vector<double> >(m, (vector<double>(l, 0.0)))));
            stan::math::initialize(t_scale, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(t_scale,DUMMY_VAR__);
            validate_non_negative_index("p_test_conj", "m", m);
            validate_non_negative_index("p_test_conj", "n_test", n_test);
            vector<vector_d> p_test_conj(n_test, (vector_d(static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(p_test_conj, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(p_test_conj,DUMMY_VAR__);
            validate_non_negative_index("log_p_test_conj", "m", m);
            validate_non_negative_index("log_p_test_conj", "n_test", n_test);
            vector<vector_d> log_p_test_conj(n_test, (vector_d(static_cast<Eigen::VectorXd::Index>(m))));
            stan::math::initialize(log_p_test_conj, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(log_p_test_conj,DUMMY_VAR__);


            for (int cat = 1; cat <= m; ++cat) {

                for (int group = 1; group <= l; ++group) {

                    for (int block = 1; block <= k; ++block) {

                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(kappa_n,block,"kappa_n",1),cat,"kappa_n",2),group,"kappa_n",3), (kappa_0 + get_base1(get_base1(n,block,"n",1),cat,group,"n",2)));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(nu_n,block,"nu_n",1),cat,"nu_n",2),group,"nu_n",3), (nu_0 + get_base1(get_base1(n,block,"n",1),cat,group,"n",2)));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(mu_n,block,"mu_n",1),cat,"mu_n",2),group,"mu_n",3), (((get_base1(mu_0,cat,"mu_0",1) * kappa_0) + (get_base1(get_base1(xbar,block,"xbar",1),cat,group,"xbar",2) * get_base1(get_base1(n,block,"n",1),cat,group,"n",2))) / get_base1(get_base1(get_base1(kappa_n,block,"kappa_n",1),cat,"kappa_n",2),group,"kappa_n",3)));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(sigma_n,block,"sigma_n",1),cat,"sigma_n",2),group,"sigma_n",3), sqrt(((((nu_0 * pow(get_base1(sigma_0,cat,"sigma_0",1),2)) + get_base1(get_base1(ss,block,"ss",1),cat,group,"ss",2)) + (((get_base1(get_base1(n,block,"n",1),cat,group,"n",2) * kappa_0) / get_base1(get_base1(get_base1(kappa_n,block,"kappa_n",1),cat,"kappa_n",2),group,"kappa_n",3)) * pow((get_base1(mu_0,cat,"mu_0",1) - get_base1(get_base1(xbar,block,"xbar",1),cat,group,"xbar",2)),2))) / get_base1(get_base1(get_base1(nu_n,block,"nu_n",1),cat,"nu_n",2),group,"nu_n",3))));
                        stan::math::assign(get_base1_lhs(get_base1_lhs(get_base1_lhs(t_scale,block,"t_scale",1),cat,"t_scale",2),group,"t_scale",3), (get_base1(get_base1(get_base1(sigma_n,block,"sigma_n",1),cat,"sigma_n",2),group,"sigma_n",3) * sqrt(((get_base1(get_base1(get_base1(kappa_n,block,"kappa_n",1),cat,"kappa_n",2),group,"kappa_n",3) + 1) / get_base1(get_base1(get_base1(kappa_n,block,"kappa_n",1),cat,"kappa_n",2),group,"kappa_n",3)))));
                    }
                }
            }
            for (int j = 1; j <= n_test; ++j) {
                {
                int group(0);
                (void) group;  // dummy to suppress unused var warning

                stan::math::fill(group, std::numeric_limits<int>::min());
                int blck(0);
                (void) blck;  // dummy to suppress unused var warning

                stan::math::fill(blck, std::numeric_limits<int>::min());


                stan::math::assign(group, get_base1(y_test,j,"y_test",1));
                stan::math::assign(blck, get_base1(block_test,j,"block_test",1));
                for (int cat = 1; cat <= m; ++cat) {

                    stan::math::assign(get_base1_lhs(get_base1_lhs(log_p_test_conj,j,"log_p_test_conj",1),cat,"log_p_test_conj",2), student_t_log(get_base1(x_test,j,"x_test",1),get_base1(get_base1(get_base1(nu_n,blck,"nu_n",1),cat,"nu_n",2),group,"nu_n",3),get_base1(get_base1(get_base1(mu_n,blck,"mu_n",1),cat,"mu_n",2),group,"mu_n",3),get_base1(get_base1(get_base1(t_scale,blck,"t_scale",1),cat,"t_scale",2),group,"t_scale",3)));
                }
                stan::math::assign(get_base1_lhs(p_test_conj,j,"p_test_conj",1), exp(subtract(get_base1(log_p_test_conj,j,"log_p_test_conj",1),log_sum_exp(get_base1(log_p_test_conj,j,"log_p_test_conj",1)))));
                }
            }

            // validate transformed parameters
            for (int k0__ = 0; k0__ < k; ++k0__) {
                for (int k1__ = 0; k1__ < m; ++k1__) {
                    for (int k2__ = 0; k2__ < l; ++k2__) {
                        check_greater_or_equal(function__,"kappa_n[k0__][k1__][k2__]",kappa_n[k0__][k1__][k2__],0);
                    }
                }
            }
            for (int k0__ = 0; k0__ < k; ++k0__) {
                for (int k1__ = 0; k1__ < m; ++k1__) {
                    for (int k2__ = 0; k2__ < l; ++k2__) {
                        check_greater_or_equal(function__,"sigma_n[k0__][k1__][k2__]",sigma_n[k0__][k1__][k2__],0);
                    }
                }
            }
            for (int k0__ = 0; k0__ < k; ++k0__) {
                for (int k1__ = 0; k1__ < m; ++k1__) {
                    for (int k2__ = 0; k2__ < l; ++k2__) {
                        check_greater_or_equal(function__,"nu_n[k0__][k1__][k2__]",nu_n[k0__][k1__][k2__],0);
                    }
                }
            }
            for (int k0__ = 0; k0__ < k; ++k0__) {
                for (int k1__ = 0; k1__ < m; ++k1__) {
                    for (int k2__ = 0; k2__ < l; ++k2__) {
                        check_greater_or_equal(function__,"t_scale[k0__][k1__][k2__]",t_scale[k0__][k1__][k2__],0);
                    }
                }
            }
            for (int k0__ = 0; k0__ < n_test; ++k0__) {
                stan::math::check_simplex(function__,"p_test_conj[k0__]",p_test_conj[k0__]);
            }

            // write transformed parameters
            for (int k_2__ = 0; k_2__ < l; ++k_2__) {
                for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < k; ++k_0__) {
                    vars__.push_back(mu_n[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < l; ++k_2__) {
                for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < k; ++k_0__) {
                    vars__.push_back(kappa_n[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < l; ++k_2__) {
                for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < k; ++k_0__) {
                    vars__.push_back(sigma_n[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < l; ++k_2__) {
                for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < k; ++k_0__) {
                    vars__.push_back(nu_n[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < l; ++k_2__) {
                for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < k; ++k_0__) {
                    vars__.push_back(t_scale[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_test; ++k_0__) {
                vars__.push_back(p_test_conj[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < m; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_test; ++k_0__) {
                vars__.push_back(log_p_test_conj[k_0__][k_1__]);
                }
            }

            if (!include_gqs__) return;
            // declare and define generated quantities



            // validate generated quantities

            // write generated quantities
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_conj_id_lapsing_sufficient_stats_incremental_fit";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "kappa_0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu_0";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lapse_rate" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_2__ = 1; k_2__ <= l; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mu_n" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= l; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "kappa_n" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= l; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "sigma_n" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= l; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "nu_n" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= l; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "t_scale" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "log_p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "kappa_0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "nu_0";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= m; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma_0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lapse_rate" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_2__ = 1; k_2__ <= l; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mu_n" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= l; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "kappa_n" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= l; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "sigma_n" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= l; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "nu_n" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= l; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= k; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "t_scale" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_1__ = 1; k_1__ <= (m - 1); ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= m; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_test; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "log_p_test_conj" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
    }

}; // model

}




#endif
